/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.0.9 D:/udemy/playpool/public/untitled.glb -t
"Pool Table" () by Pieter Ferreira is licensed under Creative Commons Attribution (http://creativecommons.org/licenses/by/4.0/).
*/

import React from "react";

import { Center, useGLTF } from "@react-three/drei";
import { CuboidCollider, RigidBody, useRapier } from "@react-three/rapier";
import type * as THREE from "three";
import type { GLTF } from "three-stdlib";

import { PHYSIC_CONSTANTS } from "@/constants/PHYSICS";
import type { BallId } from "@/utils/ballsStore";
import { useBallsStore } from "@/utils/ballsStore";

export default function Model(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    "/pool_table.glb"
  ) as unknown as GLTFResult;

  const setBallStatus = useBallsStore((state) => state.setBallStatus);
  const rapier = useRapier();
  rapier.world.raw().integrationParameters.predictionDistance = 0.01;

  return (
    <>
      <Center getObjectsByProperty={undefined} position-y={-0.5} {...props}>
        <RigidBody
          type="fixed"
          colliders="trimesh"
          friction={PHYSIC_CONSTANTS.TABLE_FRICTION}
          restitution={PHYSIC_CONSTANTS.TABLE_RESTITUTION}
        >
          <group
            rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
            dispose={null}
            scale={1.11}
          >
            <mesh
              geometry={nodes.Object_2.geometry}
              material={materials.None}
            />
          </group>
        </RigidBody>
      </Center>

      <CuboidCollider
        args={[0.7, 0.1, 1.2]}
        position={[0, -0.12, 0]}
        sensor
        name="pocket"
        onIntersectionEnter={(e) => {
          const ballId = e.other.rigidBodyObject?.userData.id;
          if (typeof ballId !== "number") return;

          setBallStatus("pocket", ballId as BallId);
        }}
      />
      <CuboidCollider
        args={[0.7, 0.22, 1.2]}
        position={[0, 0, 0]}
        sensor
        name="out"
        onIntersectionExit={(e) => {
          const ballId = e.other.rigidBodyObject?.userData.id;
          if (typeof ballId !== "number") return;

          setBallStatus("out", ballId as BallId);
        }}
      />

      {/* <mesh
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
        dispose={null}
        scale={1.11}
        position-y={-1}
        geometry={nodes.Object_2001.geometry}
        material={materials.None}
      /> */}
    </>
  );
}

useGLTF.preload("/pool_table.glb");

type GLTFResult = GLTF & {
  nodes: {
    Object_2: THREE.Mesh;
    Object_2001: THREE.Mesh;
    Object_2002: THREE.Mesh;
    Object_2003: THREE.Mesh;
  };
  materials: {
    None: THREE.MeshStandardMaterial;
  };
};
